 NAM SB68-2K6 (18) CPU02CMI MONITOR
 OPT PAG
* Setting
Vers equ '7

* for 2K ROM
*ROM equ '2 K-ROM
*RAM equ $60 continuous ram
*IO  equ $F000

* or for 4K ROM
ROM equ '4 K-ROM
RAM equ $56 continuous ram
IO  equ $E000

 PAG

* MONITOR PROGRAM FOR THE 68X02 SYSTEM
* PRODUCTS CPUXXCMI BOARD AS COMMENTED BY....

* ALLEN CLARK            WALLACE WATSON
* 2502 REGAL OAKS LANE   4815 EAST 97th AVE.
* LUTZ, FLA. 33549       TEMPLE TERRACE, FLA. 33617
* PH. 813-977-0347       PH. 813-985-1359

* MODIFIED TO SBUG09 VER 1.8 BY:  RANDY JARRETT
*                                 2561 NANTUCKET DR APT. E
*                                 ATLANTA, GA  30345
*                                 PH. 404-320-1043
*
* AGAIN MODIFIED             BY:  KEES SCHOENMAKERS
*                                 DE RIJF 20
*                                 5258JB, BERLICUM
*
* AGAIN MODIFIED (2024-05-14) CAJ
*       Cleanup mnemonic's
*       Resolved P command       
*       Added MEMCON memory test 
*       auto cable select
*

* AGAIN MODIFIED (2024-05-16) CAJ
*       Modified U to load a BOOT loader
*       Use TSC's  $A100

* AGAIN MODIFIED (2024-05-20) CAJ
*       auto cable boot select

* AGAIN MODIFIED (2024-06-26) CAJ
*       add BOOT Power/ON delay for 12Mhz card
*       resolved 16 bit low/high tests
*       resolved breakpoint upper mem test

* AGAIN MODIFIED (2024-07-01) CAJ
*       resolved set Breakpoint

* AGAIN MODIFIED (2024-07-04) CAJ
*       resolved SEARCH BREAKPOINT TABLE
*       resolved RPLSWI and FFSTBL
*       change MINBOOT messages

* AGAIN MODIFIED (2024-07-21) CAJ
*       typos in dens

* AGAIN MODIFIED (2024-10-18) CAJ
*       rewrote PUNCH

* AGAIN Modified (2025-04-30) CAJ
* OOPS A and B wrong on the stack
* Speedup BOOT

* Again modified (2025-10-04) CAJ
* Adapted source for 2K and 4K ROM
* resolved Breakpoint and SWI register display
* resolved Display stack

* Again modified (2025-10-23) CA
* Make 2K and 4K rom bootloader witch as n 09 monitr.

*       *** COMMANDS ***

* CONTROL A   = ALTER THE "A" ACCUMULATOR
* CONTROL B   = ALTER THE "B" ACCUMULATOR
* CONTROL C   = ALTER THE CONDITION CODE REGISTER
* CONTROL P   = ALTER THE PROGRAM COUNTER
* CONTROL X   = ALTER "X" INDEX REGISTER
* B hhhh      = SET BREAKPOINT AT LOCATION $hhhh
* U           = BOOT A 09FLP 5 INCH FLOPPY SYSTEM
* E ssss-eeee = EXAMINE MEMORY FROM STARTING ADDRESS ssss
*              -TO ENDING ADDRESS eeee.
* G           = CONTINUE EXECUTION FROM BREAKPOINT OR SWI
* L           = LOAD TAPE
* M hhhh      = EXAMINE AND CHANGE MEMORY LOCATION hhhh
* P ssss-eeee = PUNCH TAPE, START ssss TO END eeee ADDR.
* Q ssss-eeee = TEST MEMORY FROM ssss TO eeee
* R           = DISPLAY REGISTER CONTENTS
* S           = DISPLAY STACK FROM ssss TO $CFC0
* X           = REMOVE ALL BREAKPOINTS

romstk equ IO+$7af
loader equ $A100 Boot loader
dens equ loader+4
DP equ loader+9 keep old loader working
vectors equ $FFF8

 ORG IO+$7C0

STACK RMB 2 TOP OF INTERNAL STACK / USER VECTOR
TRAP RMB 2 NMI
SWI RMB 2 SOFTWARE INTERRUPT VECTOR
IRQ RMB 2 INTERRUPT VECTOR
CPORT RMB 2 RE-VECTORABLE CONTROL PORT
ECHO RMB 1 ECHO FLAG
XWORK2 rmb 2
ATEMP equ *
BTEMP equ *+1
DTEMP rmb 2
 rmb 2
XTEMP rmb 2
YTEMP rmb 2
UTEMP rmb 2
BPTBL RMB 24 BREAKPOINT TABLE BASE ADDR
flpspd rmb 1 floppy data speed
cable rmb 1 cable type
XWORK1 RMB 2

ACIAS EQU IO+$004 CONTROL PORT

fdccmd EQU IO+$100 COMMAND REGISTER
fdctrk EQU IO+$101 DRIVE REGISTER
fdcsec EQU IO+$102 SECTOR REGISTER
fdcdat EQU IO+$103 DATA REGISTER
fdcsel EQU IO+$104 drive select
fdcsta EQU IO+$108 drive status

D5INCH equ %01000000
DSINGLE equ %00100000

* 6800 stack order
RCCOFF equ 0
RRBOFF equ 1
RRAOFF equ 2
RXHOFF equ 3
RXLOFF equ 4
RPHOFF equ 5
RPLOFF equ 6

 ORG $F800
 FDB MONITOR
 FDB NEXTCMD
 FDB INCH
 FDB INCHE
 FDB INCHEK
 FDB OUTCH
 FDB PDATA
 FDB PCRLF
 FDB PSTRNG
 FDB LRA

* MONITOR. PRESET VECTORS
MONITOR LDX #RAMVEC POINT TO VECTOR ADDR. STRING
 stx XTEMP
 LDX #TRAP POINT TO NMI RAM VECTOR LOCATION
 stx YTEMP
*
 LDAB #6 BYTES TO MOVE
LOOPA ldx XTEMP
 LDAA ,X GET VECTOR BYTE
 inx
 stx XTEMP
 ldx YTEMP
 STAA ,X PUT VECTORS IN RAM / $F7C2-$F7C8
 inx
 stx YTEMP
 DECB SUBTRACT 1 FROM NUMBER OF BYTES TO MOVE
 BNE LOOPA CONTINUE UNTIL ALL VECTORS MOVED
 clr flpspd
 LDX #ACIAS GET CONTROL PORT ADDR.
 STX CPORT STORE ADDR. IN RAM
 JSR XBKPNT CLEAR OUTSTANDING BREAKPOINTS
 ldx STACK
 inx
 ldaa #$D0
 staa RCCOFF,x CC
 clr RRBOFF,x B
 clr RRAOFF,x A
 clr RXHOFF,x XH
 clr RXLOFF,x XL
 ldaa #MONITOR/256
 staa RPHOFF,x
 ldaa #MONITOR&255
 staa RPLOFF,x
 JSR ACINIZ INITIALIZE CONTROL PORT
 LDX #MSG1 POINT TO 'SBUG 1.8' MESSAGE
 JSR PDATA PRINT MSG
 LDAA #RAM FIXED SIZE FOR CPUXXCMI
 JSR OUT2H OUTPUT HEX BYTE AS ASCII
 LDX #MSG2 POINT TO MSG 'K' CR/LF + 3 NULS
 JSR PDATA PRINT MSG

***** NEXTCMD *****
NEXTCMD LDX #MSG3 POINT TO MSG ">"
 JSR PSTRNG PRINT MSG
 JSR INCH GET ONE CHAR. FROM TERMINAL
 ANDA #$7F STRIP PARITY FROM CHAR.
 CMPA #$0D IS IT CARRIAGE RETURN ?
 BEQ NEXTCMD IF CR THEN GET ANOTHER CHAR.
 TAB PUT CHAR. IN "B" ACCUM.
 CMPA #$20 IS IT CONTROL OR DATA CHAR ?
 BGE PRTCMD IF CMD CHAR IS DATA, PRNT IT
 LDAA #'^ ELSE CNTRL CHAR CMD SO...
 JSR OUTCH PRINT "^"
 TBA RECALL CNTRL CMD CHAR
 ADDA #$40 CONVERT IT TO ASCII LETTER
PRTCMD JSR OUTCH PRNT CMD CHAR
 JSR OUT1S PRNT SPACE
 CMPB #$60
 BLE NXTCH0
 SUBB #$20


***** DO TABLE LOOKUP *****
* FOR COMMAND FUNCTIONS
NXTCH0 LDX #JMPTAB POINT TO JUMP TABLE
NXTCHR CMPB X DOES COMMAND MATCH TABLE ENTRY ?
 BEQ JMPCMD BRANCH IF MATCH FOUND
 INX
 INX
 INX POINT TO NEXT ENTRY IN TABLE
 CPX #TABEND REACHED END OF TABLE YET ?
 BNE NXTCHR IF NOT END, CHECK NEXT ENTRY
 LDX #MSG4 POINT TO MSG "WHAT?"
 JSR PDATA PRINT MSG
 BRA NEXTCMD IF NO MATCH, PRMPT FOR NEW CMD
JMPCMD INX
 LDX 0,x
 JSR 0,x
 BRA NEXTCMD PROMPT FOR NEW COMMAND

* "G" GO OR CONTINUE
GO ldx STACK
 inx
 ldaa RPHOFF,x test PC < monitor
 cmpa #STACK/256
 blo CONT
 ldaa #MONITOR/256 set PC
 staa RPHOFF,x
 ldaa #MONITOR&255
 staa RPLOFF,x
 bra NEXTCMD wait

CONT lds STACK run it
RTI RTI

* "R" DISPLAY REGISTERS
REGSTR LDX #MSG5 POINT TO MSG " - "
 JSR PSTRNG PRINT MSG
 JSR PRTSP
 JSR PRTIX
 LDX #MSG5 POINT TO MSG " - "
 JSR PSTRNG PRINT MSG
 JSR PRTCC
 JSR PRTA
 JSR PRTB
 JMP PRTPC

* ALTER "PC" PROGRAM COUNTER
ALTRPC JSR PRTPC $FCF5 PRINT MSG " PC = "
 JSR OUT1S OUTPUT SPACE
 JSR IN1ADR GET NEW CONTENTS FOR "PC"
 BVS ALTPCD EXIT IF INVALID HEX
 ldx STACK
 inx
 ldaa XTEMP
 staa RPHOFF,x
 ldaa XTEMP+1
 staa RPLOFF,x
ALTPCD RTS

* ALTER "X" INDEX REGISTER
ALTRX JSR PRTIX $FCE0 PRINT MSG " IX = "
 JSR OUT1S OUTPUT SPACE
 JSR IN1ADR
 BVS ALTXD
 ldaa XTEMP
 ldx STACK
 inx
 staa RXHOFF,x
 ldaa XTEMP+1
 staa RXLOFF,x
ALTXD RTS

* ALTER "B" ACCUMULATOR
ALTRB JSR PRTB $FD09 PRINT MSG " B = "
 JSR OUT1S OUTPUT SPACE
 JSR BYTE INPUT BYTE (2 HEX CHAR)
 BVS ALTBD
 ldx STACK
 inx
 STAA RRBOFF,x
ALTBD RTS $F91C

* ALTER "A" ACCUMULATOR
ALTRA JSR PRTA $FCFF RINT MSG " A = "
 JSR OUT1S OUTPUT SPACE
 JSR BYTE INPUT BYTE (2 HEX CHAR)
 BVS ALTAD
 ldx STACK
 inx
 STAA RRAOFF,x
ALTAD RTS

* ALTER "CC" REGISTER
ALTRCC JSR PRTCC $FD13 PRINT MSG " CC: "
 JSR OUT1S OUTPUT SPACE
 JSR BYTE INPUT BYTE (2 HEX CHAR)
 BVS ALTCCD
 ORAA #$80 SETS "E" FLAG IN PRINT LIST
 ldx STACK
 inx
 STAA RCCOFF,x
ALTCCD RTS

***** "M" MEMORY EXAMINE AND CHANGE *****
MEMCHG JSR IN1ADR INPUT ADDRESS
 BVS CHRTN IF NOT HEX, RETURN
MEMC2 stx YTEMP
 LDX #MSG5 POINT TO MSG " - "
 JSR PSTRNG PRINT MSG
 ldx YTEMP
 JSR OUT4H PRINT ADDR IN HEX
 JSR OUT1S OUTPUT SPACE
 ldx YTEMP
 LDAA 0,x GET CONTENTS OF CURRENT ADDR.
 JSR OUT2H OUTPUT CONTENTS IN ASCII
 JSR OUT1S OUTPUT SPACE
 JSR BYTE LOOP WAITING FOR OPERATOR INPUT
 BVC CHANGE IF VALID HEX GO CHANGE MEM. LOC.
 CMPA #8 IS IT A BACKSPACE (CNTRL H)?
 BEQ MEMC2 PROMPT OPERATOR AGAIN
 CMPA #$18 IS IT A CANCEL (CNTRL X)?
 BEQ MEMC2 PROMPT OPERATOR AGAIN
 CMPA #'^ IS IT AN UP ARROW?
 BEQ BACK DISPLAY PREVIOUS BYTE
 CMPA #$D IS IT A CR?
 BNE FORWRD DISPLAY NEXT BYTE
CHRTN RTS EXIT ROUTINE

CHANGE STAA ,X CHANGE BYTE IN MEMORY
 CMPA ,X DID MEMORY BYTE CHANGE?
 BEQ FORWRD $F972
 JSR OUT1S OUTPUT SPACE
 LDAA #'? LOAD QUESTION MARK
 JSR OUTCH PRINT IT
FORWRD INX POINT TO NEXT HIGHER MEM LOCATION
 BRA MEMC2 PRINT LOCATION & CONTENTS
BACK DEX POINT TO LAST MEM LOCATION
 BRA MEMC2 PRINT LOCATION & CONTENTS

* "S" DISPLAY STACK
* HEX-ASCII DISPLAY OF CURRENT STACK CONTENTS FROM
* CURRENT STACK POINTER TO INTERNAL STACK LIMIT.
DISSTK JSR PRTSP PRINT CURRENT STACK POINTER
 tsx
 stx YTEMP
 LDX #romstk+1 LOAD INTERNAL STACK AS UPPER LIMIT
 stx XTEMP
* INX POINT TO CURRENT STACK
 BRA MDUMP1 ENTER MEMORY DUMP OF STACK CONTENTS

* "E" DUMP MEMORY FOR EXAMINE IN HEX AND ASCII
* AFTER CALLING 'IN2ADR' LOWER ADDRESS IN YTEMP
* UPPER ADDRESS IN XTEMP
* IF HEX ADDRESSES ARE INVALID (V)=1.
MEMDUMP JSR IN2ADR INPUT ADDRESS BOUNDRIES
 BVS EDPRTN NEW COMMAND IF ILLEGAL HEX
 cpx YTEMP with XTEMP already in X-reg.
 beq EDPRTN LOW = HIGH
MDUMP1 LDAA XTEMP+1
  cmpa YTEMP+1
 LDAB XTEMP
 sbcb YTEMP
 bcc AJDUMP LOW < HIGH
EDPRTN RTS

* ADJUST LOWER AND UPPER ADDRESS LIMITS
* TO EVEN 16 BYTE BOUNDRIES.

* IF LOWER ADDR = $4532
* LOWER BOUNDS WILL BE ADJUSTED TO = $4530.
* IF UPPER ADDR = $4567
* UPPER BOUNDS WILL BE ADJUSTED TO = $4570.

* ENTER WITH LOWER ADDRESS IN X-REG.
* -UPPER ADDRESS ON TOP OF STACK.

AJDUMP stx DTEMP GET UPPER ADDR IN D-REG
 LDAA DTEMP
 LDAB DTEMP+1
 ADDB #16
 ADCA #0
 ANDB #$F0
 staa DTEMP
 stab DTEMP+1
 ldaa YTEMP
 ldab YTEMP+1
 andb #$f0
 staa YTEMP
 stab YTEMP+1
 ldx YTEMP
NXTLIN cpx DTEMP
 BEQ SKPDMP IF EQUAL SKIP HEX-ASCII DUMP
 ldx YTEMP
 JSR INCHEK CHECK FOR INPUT FROM KEYBOARD
 BEQ EDUMP IF NONE, CONTINUE WITH DUMP
SKPDMP RTS

* PRINT 16 HEX BYTES FOLLOWED BY 16 ASCII CHARACTERS
* FOR EACH LINE THROUGHOUT ADDRESS LIMITS.
EDUMP stx XTEMP
 LDX #MSG5 POINT TO MSG " - "
 JSR PSTRNG PRINT MSG
 ldx XTEMP
 JSR OUT4H PRINT THE ADDRESS
 JSR OUT2S PRINT 2 SPACES
 ldx XTEMP
 LDAB #$10 LOAD COUNT OF 16 BYTES TO DUMP
ELOOP LDAA ,X GET FROM MEMORY HEX BYTE TO PRINT
 INX
 JSR OUT2H OUTPUT HEX BYTE AS ASCII
 JSR OUT1S OUTPUT SPACE
 DECB $F9D1 DECREMENT BYTE COUNT
 BNE ELOOP CONTINUE TIL 16 HEX BYTES PRINTED

* PRINT 16 ASCII CHARACTERS
* IF NOT PRINTABLE OR NOT VALID
* ASCII PRINT A PERIOD (.)
 JSR OUT2S 2 SPACES
 LDX XTEMP GET LOW LIMIT FRM STACK - ADJ STACK
 LDAB #$10 SET ASCII CHAR TO PRINT = 16
EDPASC LDAA ,X GET CHARACTER FROM MEMORY
 INX
 CMPA #$20 IF LESS THAN $20, NON-PRINTABLE?
 BCS PERIOD IF SO, PRINT PERIOD INSTEAD
 CMPA #$7E IS IT VALID ASCII?
 BLS PRASC IF SO PRINT IT
PERIOD LDAA #'. LOAD A PERIOD (.)
PRASC JSR OUTCH PRINT ASCII CHARACTER
 DECB DECREMENT COUNT
 BNE EDPASC
 stx YTEMP
 BRA NXTLIN

***** "B" SET BREAKPOINT *****
BRKPNT JSR IN1ADR GET BREAKPOINT ADDRESS
 BVS EXITBP EXIT IF INVALID HEX ADDR.
 stx DTEMP
 LDAA #STACK<<8-1
 CMPA DTEMP+1
 ldab #STACK/256
 sbcb DTEMP
 bcc BRK X < #STACK
* INDICATE ERROR SETTING BREAKPOINT
BPERR jsr OUT1S OUTPUT SPACE
 ldaa #'? LOAD (?), INDICATE BREAKPOINT ERROR
 jmp OUTCH

BRK
 LDX #$FFFF LOAD DUMMY ADDR TO TEST BP TABLE
 JSR BPTEST TEST BP TABLE FOR FREE SPACE
 tpa
 ldx DTEMP
 tap
 BEQ BPERR (Z) SET, OUT OF BP TABLE SPACE
 LDAA ,X GET DATA AT BREAKPOINT ADDRESS
 CMPA #$3F IS IT A SWI?
 BEQ BPERR IF SWI ALREADY, INDICATE ERROR
 ldx YTEMP
 STAA ,x SAVE DATA BYTE IN BP TABLE
 LDAA DTEMP
 STAA 1,x
 LDAA DTEMP+1
 STAA 2,x
 ldx DTEMP
 LDAA #$3F LOAD A SWI ($3F)
 STAA ,X SAVE SWI AT BREAKPOINT ADDRESS
EXITBP RTS

*** "X" CLEAR OUTSTANDING BREAKPOINTS ***
XBKPNT LDX #BPTBL POINT TO BREAKPOINT TABLE
 stx YTEMP
 LDAB #8 LOAD BREAKPOINT COUNTER
XBPLP STAB BTEMP
 BSR RPLSWI REMOVE USED ENTRY IN BP TABLE
 LDAB BTEMP
 DECB $FAAC DECREMENT BP COUNTER
 BNE XBPLP END OF BREAKPOINT TABLE?
 RTS

***** SWI ENTRY POINT *****
SWIE TSX TRANSFER STACK TO USER POINTER
 STX UTEMP
 ldx UTEMP
 LDX RPHOFF,X LOAD PC FROM STACK INTO X-REG
 DEX ADJUST ADDR DOWN 1 BYTE.
 stx UTEMP save PC
 BSR BPTEST FIND BREAKPOINT IN BP TABLE
 BEQ REGPR ** IF FOUND, REPLACE DATA AT BP ADDR
 STX XTEMP
 BSR RPLSWI GO REPLACE SWI WITH ORIGINAL DATA
REPRC ldx STACK
 inx
 ldaa UTEMP set PC back on STACK
 ldab UTEMP+1
 staa RPHOFF,x
 stab RPLOFF,x
REGPR JSR REGSTR GO PRINT REGISTERS
 JMP NEXTCMD GET NEXT COMMAND

RPLSWI LDX YTEMP
 LDAA 1,X LOAD BP ADDRESS FROM BP TABLE
 LDAB 2,x
 staa XTEMP SAVE BREAKPOINT ADDRESS
 stab XTEMP+1
 suba #STACK/256
 bhs FFSTBL
 sbcb #STACK<<8-1
 bhs FFSTBL
 ldx XTEMP
 LDAA ,X GET DATA FROM BP ADDRESS
 CMPA #$3F IS IT SWI?
 BNE FFSTBL IF NOT, RESET TABLE ENTRY TO $FF'S
 ldx YTEMP
 LDAA ,X GET ORIGINAL DATA FROM BP TABLE
 ldx XTEMP
 STAA ,X RESTORE DATA AT BP ADDRESS
FFSTBL LDAA #$FF LOAD $FF IN A-ACC
 ldx YTEMP
 STAA 0,x RESET BREAKPOINT TABLE DATA TO $FF'S
 STAA 1,x RESET BREAKPOINT TABLE ADDR TO $FF'S
 STAA 2,x
 inx
 inx
 inx
 stx YTEMP SAVE NEW ENTRY
 RTS

** SEARCH BREAKPOINT TABLE FOR MATCH **
BPTEST stx XTEMP
 LDX #BPTBL POINT TO BREAKPOINT TABLE
 stx YTEMP
 LDAB #8 LOAD BREAKPOINT COUNTER
FNDBP ldx YTEMP
 LDAA ,X LOAD DATA BYTE, AND SKIP
 ldaa XTEMP
 suba 1,x MSB address FROM BREAKPOINT TABLE
 BNE FNDB
 LDAA XTEMP+1
 sbca 2,x LSB address FROM BREAKPOINT TABLE
 BEQ BPADJ IF SO, POINTER FOR TABLE ENTRY
FNDB inx
 inx
 inx
 stx YTEMP NEXT ENTRY
 DECB IF NOT, DECREMENT BREAKPOINT COUNTER
 BNE FNDBP AND LOOK FOR NEXT POSSIBLE MATCH
 RTS RETURN TABLE FULL

BPADJ stx YTEMP POINTER FOR TABLE ENTRY
 RTS

***** "U" MINIDISK BOOT *****
MINBOOT clr fdcsel
 tst cable PowerOn/Reset
 bne NoDel Reboot
 ldab #1 GoTek PowerOn delay 12MHz card
 jsr Pdelay
NoDel ldaa #%00000001 select drive 0
 STAA fdcsel
 bsr Delay
 ldab fdccmd ready?
 bmi setPC no, test PC cable
 bra set1 yes, straight cable
setPC ldaa #%00000101 select drive 0
set1 staa cable Set cable type
 oraa #$30
 jsr OUTCH Show cable type
 tst fdcsel
minbo1 ldab flpspd
 ldaa #$38 show 8" drive type
 bitb #D5INCH test drive type
 beq minbo2
 ldaa #$35 show 5" drive type
minbo2 jsr OUTCH
* drive select on cable, 1 = FLEX 5 = PC compatible
 ldaa flpspd
 oraa cable drive 0 or PC cable drive 1
 oraa #DSINGLE FLEX has SD boot only
 staa fdcsel select drive 0
* delay before issuing restore command
 bsr Delay
 ldab fdccmd
 bmi loop9

 LDAA #$09 *LOAD HEAD, VERIFY, 12msec/step
 STAA fdccmd ISSUE RESTORE COMMAND
LOOP1 LDAB fdcsta
 aslb
 bpl LOOP1 LOOP UNTIL THRU
*
 LDAA #1
 STAA fdcsec SET SECTOR REGISTER TO ONE
 LDAA #$88 LOAD HEAD, DELAY 10msec,
 STAA fdccmd AND READ SINGLE RECORD
 LDX #loader Put it here
 BRA LOOP3

* DELAY BEFORE ISSUING RESTORE COMMAND
Delay LDAB #2
Pdelay LDX #0
LOOP inx
 tst fdcsel keep active
 CPX #0
 BNE LOOP
 DECB
 BNE LOOP
 rts

LOOP2 LDAA fdcdat
 STAA ,X
 INX

LOOP3 LDAB fdcsta FETCH STATUS
 BMI LOOP2
 BEQ LOOP3
 LDAB fdccmd
 BITB #%00011100 CRC ERROR OR LOST DATA?
 BEQ LOOP4

 ldaa flpspd
 eora #D5INCH
 staa flpspd
 bita #D5INCH
 bne minbo1
loop9 RTS

LOOP4 ldx #loader boot code
 ldaa IOVEC
 inca
 staa DP
 ldaa dens
 anda #$F0 remove drive
 oraa cable
 staa dens
 tsx
 LDAA #loader/256
 LDAB #loader<<8
 staa RPHOFF,X
 stab RPLOFF,X
 RTI run loader

* for compatibillity
LRA clra
 rts

***** "L" LOAD MIKBUG TAPE *****
LOAD CLR ECHO TURN OFF ECHO FLAG
LOAD1 JSR ECHON INPUT 8 BIT BYTE WITH NO ECHO
LOAD2 ORAA #$20
 CMPA #'s IS IT AN "S", START CHARACTER ?
 BNE LOAD1 IF NOT, DISCARD AND GET NEXT CHAR.
 JSR ECHON
 CMPA #'9 IS IT A "9" , END OF FILE CHAR ?
 BEQ LOAD21 IF SO, EXIT LOAD
 CMPA #'1 IS IT A "1" , FILE LOAD CHAR ?
 BNE LOAD2 IF NOT, LOOK FOR START CHAR.
 JSR BYTE INPUT BYTE COUNT
 BVS LODERR (V) C-CODE SET, ILLEGAL HEX
 staa ATEMP
 JSR IN1ADR INPUT LOAD ADDRESS
 BVS LODERR (V) C-CODE SET, ADDR NOT HEX
 LDAB XTEMP
 ADDB XTEMP+1
 ADDB ATEMP
 DEC ATEMP bytecount
 DEC ATEMP
LOAD10 PSHB PUSH CHECKSUM ON STACK
 JSR BYTE INPUT DATA BYTE (2 HEX CHAR)
 PULB POP CHECKSUM FROM STACK
 BVS LODERR (V) SET, DATA BYTE NOT HEX
 staa BTEMP
 ADDB BTEMP
 DEC ATEMP DECREMENT BYTE COUNT 1
 BEQ LOAD16 IF BYTE COUNT ZERO, TEST CHECKSUM
 STAA ,X SAVE DATA BYTE IN MEMORY
 cmpa ,x check
 bne LODERR
 INX
 BRA LOAD10 GET NEXT DATA BYTE
LODERR CLRB ERROR CONDITION, ZERO CHECKSUM
LOAD16 CMPB #$FF CHECKSUM OK?
 BEQ LOAD IF SO, LOAD NEXT LINE
 LDAA #'? LOAD (?) ERROR INDICATOR
LOAD21 COM ECHO TURN ECHO ON
 JMP OUTCH OUTPUT IT

***** "P"     PUNCH MIKBUG TAPE *****
PUNCH
 JSR IN2ADR GET BEGIN AND END ADDRESS
 BVS PUNEXT (V) C-CODE SET, EXIT PUNCH
 cpx YTEMP with XTEMP already in X-reg.
 beq PUNEXT LOW = HIGH
 LDAA #$12 LOAD 'DC2' PUNCH ON CODE
 JSR OUTCH
PUN11 LDAA XTEMP+1
 SUBA YTEMP+1
 LDAB XTEMP
 SBCB YTEMP
 bcs punoff LOW > HIGH
 BNE PUN22
 CMPA #16
 BCS PUN23
PUN22 LDAA #15
PUN23 ADDA #4
 STAA ATEMP
 SUBA #3
 STAA BTEMP
 LDX #MSG20 POINT TO MSG "S1"
 JSR PSTRNG
 CLRB
 LDX #ATEMP PUNCH FRAME COUNT
 BSR PUNT2 PUNCH 2 HEX CHARACTERS
 LDX #YTEMP PUNCH ADDRESS
 BSR PUNT2
 BSR PUNT2
 LDX YTEMP PUNCH DATA
PUN32 BSR PUNT2 PUNCH ONE BYTE
 DEC BTEMP
 BNE PUN32
 STX YTEMP
 COMB
 PSHB
 TSX
 BSR PUNT2 PUNCH CHECKSUM
 PULB RESTORE STACK
 LDX YTEMP
 DEX
 CPX XTEMP
 BNE PUN11
punoff LDAA #$14 LOAD 'DC4' PUNCH OFF CODE
 JSR OUTCH OUTPUT IT
PUNEXT RTS

PUNT2 ADDB 0,X UPDATE CHECKSUM
 ldaa 0,x GET BYTE TO PUNCH
 jsr OUT2H PUNCH 2 HEX CHAR
 inx SET NEXT ONE
 rts

PRTSP LDX #MSG10 POINT TO MSG "SP="
 JSR PDATA PRINT MSG
 ldx STACK
 inx
 JMP OUT4H
PRTIX LDX #MSG14 POINT TO MSG "IX="
 JSR PDATA PRINT MSG
 ldx STACK
 ldx RXHOFF+1,x
 JMP OUT4H
PRTPC LDX #MSG11 POINT TO MSG "PC="
 JSR PDATA PRINT MSG
 ldx STACK
 ldx RPHOFF+1,x
 JMP OUT4H
PRTA LDX #MSG16 POINT TO MSG "A="
 JSR PDATA PRINT MSG
 ldx STACK
 LDAA RRAOFF+1,x
 JMP OUT2H OUTPUT HEX BYTE AS ASCII
PRTB LDX #MSG17 POINT TO MSG "B="
 JSR PDATA PRINT MSG
 ldx STACK
 LDAA RRBOFF+1,x
 BRA OUT2H OUTPUT HEX BYTE AS ASCII
PRTCC LDX #MSG18 POINT TO MSG "CC:"
 JSR PDATA PRINT MSG
 ldx STACK
 LDAA RCCOFF+1,x
 LDX #MSG19 POINT TO MSG "11HINZVC"
 BRA BIASCI OUTPUT IN BINARY/ASCII FORMAT

* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE
* OPERATOR TO INPUT TWO VALID HEX ADDRESSES.
* THE FIRST ADDRESS INPUT IS RETURNED IN "IY".
* THE SECOND IS RETURNED IN "IX". THE "V" BIT
* IN THE C-CODE REG. IS SET IF AN INVALID HEX
* ADDRESS IS INPUT.
IN2ADR BSR IN1ADR GET FIRST ADDRESS
 BVS NOTHEX EXIT IF NOT VALID HEX
 STX YTEMP
 LDAA #'-
 JSR OUTCH PRINT " - "

* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE
* OPERATOR TO INPUT ONE VALID HEX ADDRESS. THE
* ADDRESS IS RETURNED IN THE "X" REGISTER.
IN1ADR BSR BYTE INPUT BYTE (2 HEX CHAR)
 BVS NOTHEX EXIT IF NOT VALID HEX
 STAA XTEMP
 BSR BYTE INPUT BYTE (2 HEX CHAR)
 BVS NOTHEX
 STAA XTEMP+1
 LDX XTEMP
 RTS

***** INPUT BYTE (2 HEX CHAR.) *****
BYTE BSR INHEX GET HEX LEFT
 BVS NOTHEX EXIT IF NOT VALID HEX
 ASLA
 ASLA
 ASLA SHIFT INTO LEFT NIBBLE
 ASLA
 TAB PUT HEXL IN "B"
 BSR INHEX GET HEX RIGHT
 BVS NOTHEX EXIT IF NOT VALID HEX
 STAB BTEMP
 ADDA BTEMP ADD HEXL TO HEXR AND ADJ. STK
 RTS RETURN WITH HEX L&R IN "A"

INHEX BSR ECHON INPUT ASCII CHAR.
 CMPA #'0 IS IT > OR = "0" ?
 BCS NOTHEX IF LESS IT AIN'T HEX
 CMPA #'9 IS IT < OR = "9" ?
 BHI INHEXA IF > MAYBE IT'S ALPHA
 SUBA #$30 ASCII ADJ. NUMERIC
 RTS

INHEXA CMPA #'A IS IT > OR = "A"
 BCS NOTHEX IF LESS IT AIN'T HEX
 CMPA #'F IS IT < OR = "F" ?
 BHI INHEXL IF > IT AIN'T HEX
 SUBA #$37 ASCII ADJ. ALPHA
 RTS

INHEXL CMPA #'a IS IT > OR = "a"
 BCS NOTHEX IF LESS IT AIN'T HEX
 CMPA #'f IS IT < "f"
 BHI NOTHEX IF > IT AIN'T HEX
 SUBA #$57 ADJUST TO LOWER CASE
 RTS

NOTHEX psha
 TPA
 ORAA #2 #2 SET (V) FLAG IN C-CODES REGISTER
 TAP
 pula
 RTS

OUT4H stx XWORK2 PUSH X-REG. ON THE STACK
 LDAA XWORK2 MS BYTE OF X-REG INTO A-ACC.
 BSR OUTHL OUTPUT HEX LEFT
 LDAA XWORK2+1 LS BYTE OF X-REG INTO A-ACC.
OUTHL EQU *
OUT2H PSHA SAVE IT BACK ON STACK
 LSRA CONVERT UPPER HEX NIBBLE TO ASCII
 LSRA
 LSRA
 LSRA
 BSR XASCII PRINT HEX NIBBLE AS ASCII
OUTHR PULA CONVERT LOWER HEX NIBBLE TO ASCII
 ANDA #$0F STRIP LEFT NIBBLE
XASCII ADDA #$30 ASCII ADJ
 CMPA #$39 IS IT < OR = "9" ?
 BLE OUTC IF LESS, OUTPUT IT
 ADDA #7 IF > MAKE ASCII LETTER
OUTC BRA OUTCH OUTPUT CHAR

* BINARY / ASCII --- THIS ROUTINE
* OUTPUTS A BYTE IN ENHANCED
* BINARY FORMAT. THE ENHANCEMENT
* IS DONE BY SUBSTITUTING ASCII
* LETTERS FOR THE ONES IN THE BYTE.
* THE ASCII ENHANCEMENT LETTERS
* ARE OBTAINED FROM THE STRING
* POINTED TO BY THE INDEX REG. "X".
BIASCI staa ATEMP SAVE "A"
 LDAB #8 PRESET LOOP# TO BITS PER BYTE
OUTBA LDAA ,X GET LETTER FROM STRING
 INX
 ASL ATEMP TEST BYTE FOR "1" IN B7
 BCS PRTBA IF ONE PRINT LETTER
 LDAA #'- IF ZERO PRINT "-"
PRTBA BSR OUTCH PRINT IT
 BSR OUT1S PRINT SPACE
 DECB SUB 1 FROM #BITS YET TO PRINT
 BNE OUTBA
 RTS

* PRINT STRING PRECEEDED BY A CR & LF.
PSTRNG BSR PCRLF PRINT CR/LF
 BRA PDATA PRINT STRING POINTED TO BY IX

* PCRLF
PCRLF STX XWORK2 SAVE IX
 LDX #MSG2+1 POINT TO MSG CR/LF + 3 NULS
 BSR PDATA PRINT MSG
 LDX XWORK2 RESTORE IX
 RTS
PRINT BSR OUTCH

* PDATA
PDATA LDAA ,X GET 1st CHAR. TO PRINT
 inx
 CMPA #4 IS IT EOT?
 BNE PRINT IF NOT EOT PRINT IT
 RTS

ECHON TST ECHO IS ECHO REQUIRED ?
 BEQ INCH ECHO NOT REQ. IF CLEAR

* INCHE
* ---GETS CHARACTER FROM TERMINAL AND
* ECHOS SAME. THE CHARACTER IS RETURNED
* IN THE "A" ACCUMULATOR WITH THE PARITY
* BIT MASKED OFF. ALL OTHER REGISTERS
* ARE PRESERVED.
INCHE BSR INCH GET CHAR FROM TERMINAL
 ANDA #$7F STRIP PARITY FROM CHAR.
 BRA OUTCH ECHO CHAR TO TERMINAL

* INCH
* GET CHARACTER FROM TERMINAL. RETURN
* CHARACTER IN "A" ACCUMULATOR AND PRESERVE
* ALL OTHER REGISTERS. THE INPUT CHARACTER
* IS 8 BITS AND IS NOT ECHOED.
INCH STX XWORK1 SAVE IX
 LDX CPORT POINT TO TERMINAL PORT
GETSTA LDAA ,X FETCH PORT STATUS
 BITA #1 TEST READY BIT, RDRF ?
 BEQ GETSTA IF NOT RDY, THEN TRY AGAIN
 LDAA 1,X FETCH CHAR
 LDX XWORK1
 RTS

* INCHEK
* CHECK FOR A CHARACTER AVAILABLE FROM
* THE TERMINAL. THE SERIAL PORT IS CHECKED
* FOR READ READY. ALL REGISTERS ARE
* PRESERVED, AND THE "Z" BIT WILL BE
* CLEAR IF A CHARACTER CAN BE READ.
INCHEK PSHA SAVE A ACCUM.
 STX XWORK1
 LDX CPORT
 LDAA 0,x FETCH PORT STATUS
 LDX XWORK1
 BITA #1 TEST READY BIT, RDRF ?
 PULA RESTORE A ACCUM.
 RTS

OUT2S BSR OUT1S OUTPUT 2 SPACES
OUT1S LDAA #$20 OUTPUT 1 SPACE

* OUTCH
* OUTPUT CHARACTER TO TERMINAL.
* THE CHAR. TO BE OUTPUT IS
* PASSED IN THE A REGISTER.
* ALL REGISTERS ARE PRESERVED.
OUTCH PSHA
 STX XWORK1 SAVE IX
 LDX CPORT GET ADDR. OF TERMINAL
FETSTA LDAA ,X FETCH PORT STATUS
 BITA #2 TEST TDRE, OK TO XMIT ?
 BEQ FETSTA IF NOT LOOP UNTIL RDY
 PULA GET CHAR. FOR XMIT
 STAA 1,X XMIT CHAR.
 LDX XWORK1 RESTORE IX
 RTS

ACINIZ LDX CPORT POINT TO CONTROL PORT ADDRESS
 LDAA #3 RESET ACIA PORT CODE
 STAA ,X STORE IN CONTROL REGISTER
 LDAA #$11 SET 8 DATA, 2 STOP AN 0 PARITY
 STAA ,X STORE IN CONTROL REGISTER
 TST 1,X ANYTHING IN DATA REGISTER?
 LDAA #$FF TURN ON ECHO FLAG
 STAA ECHO
 RTS

***** "q" memory test *****
memtst JSR IN2ADR GET BEGIN AND END ADDRESS
 BVS Qend (V) C-CODE SET, EXIT
 cpx YTEMP with XTEMP already in X-reg.
 beq Qend LOW = HIGH
 ldaa XTEMP+1 LOW ADDRESS
 cmpa YTEMP+1 HIGH ADDRESS
 ldab XTEMP
 sbcb YTEMP
 bcc Qdo LOW < HIGH
Qext rts skip memtst LOW=HIGH, LOW > HIGH
Qdo clrb do memtst
QSTART STA B BTEMP STORE ACCCB
 jsr INCHEK CHECK FOR INPUT FROM KEYBOARD
 beq qloop
Qend rts abort > MONITOR
qloop LDX YTEMP LOAD LOW MEMORY ADDRESS
QLOOP1 STA B 0,X
 CPX XTEMP END OF MEMORY?
 BEQ CHECK CHECK IF FINISHED
 INX
 INC B
 BRA QLOOP1
CHECK LDA B BTEMP CHECKS ALL LOCATIONS FOR CORR
 LDX YTEMP
QLOOP2 CMP B 0,X
 BNE QERR
 CPX XTEMP
JUMP BEQ CYCLE
 INX
 INC B
 BRA QLOOP2
QERR LDA A #'x PRINT X IF ERROR FOUND
 JSR OUTCH
 BRA QSTART START OVER
CYCLE LDA A #'# PRINT # FOR CORRECT CYCLE
 JSR OUTCH
 DEC B
 BRA QSTART

* MONITOR KEYBOARD COMMAND JUMP TABLE
JMPTAB EQU *
 FCB 1 " ^A "
 FDB ALTRA
 FCB 2 " ^B "
 FDB ALTRB
 FCB 3 " ^C "
 FDB ALTRCC
 FCB $10 " ^P "
 FDB ALTRPC
 FCB $18 " ^X "
 FDB ALTRX

 FCC 'B'
 FDB BRKPNT 
 FCC 'E'
 FDB MEMDUMP
 FCC 'G'
 FDB GO 
 FCC 'L'
 FDB LOAD 
 FCC 'M'
 FDB MEMCHG 
 FCC 'P'
 FDB PUNCH 
 FCC 'R'
 FDB REGSTR 
 FCC 'S'
 FDB DISSTK 
 FCC 'U'
 FDB MINBOOT 
 FCC 'X'
 FDB XBKPNT 
 fcc 'Q'
 fdb memtst 
TABEND EQU *

* ** 6802 VECTOR ADDRESSES **
* FOLLOWING ARE THE ADDRESSES OF THE VECTOR ROUTINES
* FOR THE 6802 PROCESSOR. DURING INITIALIZATION THEY
* ARE RELOCATED TO RAM. THEY ARE RELOCATED TO RAM SO 
* THAT THE USER MAY REVECTOR TO HIS OWN ROUTINES IF 
* HE SO DESIRES.
RAMVEC
 FDB START NMI
 FDB SWIE SWI-V
 FDB RTI IRQ-V

* PRINTABLE MESSAGE STRINGS
MSG1 FCB $D,$A,$0,$0  CR/LF
 FCC 'SB68-'
 fcb ROM
 FCC 'K 1.8:'
 fcb Vers
 fcc ' - '
 FCB 4
MSG2 FCB 'K,$D,$A,$0,$0,4
MSG3 FCC '>'
 FCB 4
MSG4 FCC 'WHAT?'
 FCB 4
MSG5 FCC ' - '
 FCB 4
MSG6 FCC ', PASS '
 FCB 4
MSG7 FCC ', BITS IN ERROR: '
 FCB 4
MSG8 FCC ' => '
 FCB 4
MSG9 FCC '76543210'
MSG10 FCC '  SP='
 FCB 4
MSG11 FCC '  PC='
 FCB 4
MSG14 FCC '  IX='
 FCB 4
MSG16 FCC '  A='
 FCB 4
MSG17 FCC '  B='
 FCB 4
MSG18 FCC '  CC: '
 FCB 4
MSG19 FCC '11HINZVC'
MSG20 FCC 'S1'
 FCB 4


* POWER UP/ RESET/ NMI ENTRY POINT
START equ *
 lds #romstk set STACK
 sts STACK
 clr cable PowerOn/Reset

*
*  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
* 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K I/O,ROM
*
 JMP MONITOR INITIALIZATION IS COMPLETE

V1 LDAA TRAP Hi byte
 LDAB TRAP+1 Lo byte
 bra V10
V4 LDAA IRQ
 LDAB IRQ+1
 bra V10
V5 LDAA SWI
 LDAB SWI+1
V10 PSHB Lo byte
 PSHA Hi byte
 RTS

 org vectors-16
* IDE table entrys for 4K rom

* 6802 VECTORS
 ORG vectors-2

IOVEC fdb IO IO area
 FDB V4 IRQ-V
 FDB V5 SWI-V
 FDB V1 NMI-V
 FDB START RESTART-V
 END
