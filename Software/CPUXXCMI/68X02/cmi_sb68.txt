 NAM CMI_SBUG (18) CPUXXCMI MONITOR
 OPT PAG
 PAG

* MONITOR PROGRAM FOR THE 68X02 SYSTEM
* PRODUCTS CPUXXCMI BOARD AS COMMENTED BY....

* ALLEN CLARK            WALLACE WATSON
* 2502 REGAL OAKS LANE   4815 EAST 97th AVE.
* LUTZ, FLA. 33549       TEMPLE TERRACE, FLA. 33617
* PH. 813-977-0347       PH. 813-985-1359

* MODIFIED TO SBUG09 VER 1.8 BY:  RANDY JARRETT
*                                 2561 NANTUCKET DR APT. E
*                                 ATLANTA, GA  30345
*                                 PH. 404-320-1043
*
* AGAIN MODIFIED             BY:  KEES SCHOENMAKERS
*                                 DE RIJF 20
*                                 5258JB, BERLICUM
*
*


*       *** COMMANDS ***

* CONTROL A   = ALTER THE "A" ACCUMULATOR
* CONTROL B   = ALTER THE "B" ACCUMULATOR
* CONTROL E   = ALTER THE "E" ACCUMULATOR
* CONTROL F   = ALTER THE "F" ACCUMULATOR
* CONTROL C   = ALTER THE CONDITION CODE REGISTER
* CONTROL D   = ALTER THE DIRECT PAGE REGISTER
* CONTROL P   = ALTER THE PROGRAM COUNTER
* CONTROL U   = ALTER USER STACK POINTER
* CONTROL X   = ALTER "X" INDEX REGISTER
* CONTROL Y   = ALTER "Y" INDEX REGISTER
* B hhhh      = SET BREAKPOINT AT LOCATION $hhhh
* U           = BOOT A 09FLP 5 INCH FLOPPY SYSTEM
* E ssss-eeee = EXAMINE MEMORY FROM STARTING ADDRESS ssss
*              -TO ENDING ADDRESS eeee.
* G           = CONTINUE EXECUTION FROM BREAKPOINT OR SWI
* L           = LOAD TAPE
* M hhhh      = EXAMINE AND CHANGE MEMORY LOCATION hhhh
* P ssss-eeee = PUNCH TAPE, START ssss TO END eeee ADDR.
* Q ssss-eeee = TEST MEMORY FROM ssss TO eeee
* R           = DISPLAY REGISTER CONTENTS
* S           = DISPLAY STACK FROM ssss TO $DFC0
* X           = REMOVE ALL BREAKPOINTS


romstk  equ     $f7af

       ORG $F7C0

STACK  RMB 2  TOP OF INTERNAL STACK / USER VECTOR
TRAP   RMB 2  NMI
SWI    RMB 2  SOFTWARE INTERRUPT VECTOR
IRQ    RMB 2  INTERRUPT VECTOR
CPORT  RMB 2  RE-VECTORABLE CONTROL PORT
ECHO   RMB 1  ECHO FLAG
XWORK1  rmb     2
XWORK2  rmb     2
ATEMP   equ     *
BTEMP   equ     *+1
DTEMP   rmb     2
XTEMP   rmb     2
YTEMP   rmb     2
UTEMP   rmb     2

BPTBL  RMB 24 BREAKPOINT TABLE BASE ADDR
ACIAS  EQU $F004  CONTROL PORT
Comreg EQU $F100  COMMAND REGISTER
Trkreg EQU $F101  DRIVE REGISTER
Secreg EQU $F102  SECTOR REGISTER
Datreg EQU $F103  DATA REGISTER
Drvreg EQU $F104  drive select
Drvsta EQU $F108  drive status


RCCOFF  equ     0
RRAOFF  equ     1
RRBOFF  equ     2
RXHOFF  equ     3
RXLOFF  equ     4
RPHOFF  equ     5
RPLOFF  equ     6

 ORG $F800
 FDB MONITOR
 FDB NEXTCMD
 FDB INCH
 FDB INCHE
 FDB INCHEK
 FDB OUTCH
 FDB PDATA
 FDB PCRLF
 FDB PSTRNG
 FDB LRA

* MONITOR. PRESET VECTORS

MONITOR LDX #RAMVEC POINT TO VECTOR ADDR. STRING
    stx XTEMP
 LDX  #TRAP POINT TO RAM VECTOR LOCATION
    stx YTEMP
 LDAB  #6 BYTES TO MOVE
LOOPA    ldx         XTEMP
 LDAA  ,X GET VECTOR BYTE
 inx
 stx    XTEMP
 ldx    YTEMP
 STAA  ,X   PUT VECTORS IN RAM / $DFC0-$DFCF
 inx
 stx    YTEMP
 DECB SUBTRACT 1 FROM NUMBER OF BYTES TO MOVE
 BNE LOOPA CONTINUE UNTIL ALL VECTORS MOVED

* CONTENTS     FROM         TO      FUNCTION
*  $F8A1       $FE40      $F7C2     USER-V
*  $F8A1       $FE42      $F7C4     SWI3-V
*  $F8A1       $FE44      $F7C6     SWI2-V
*  $F8A1       $FE46      $F7C8     FIRQ-V
*  $F8A1       $FE48      $F7CA     IRQ-V
*  $FAB0       $FE4A      $F7CC     SWI-V
*  $FFFF       $FE4C      $F7CE     SVC-VO
*  $FFFF       $FE4E      $F7D0     SVC-VL

 LDX  #ACIAS  GET CONTROL PORT ADDR.
 STX  CPORT   STORE ADDR. IN RAM
 JSR  XBKPNT  CLEAR OUTSTANDING BREAKPOINTS
 ldx    STACK
 inx
 ldaa #$D0
 staa  RCCOFF,x  CC
 clr  RRAOFF,x  A
 clr  RRBOFF,x  B
 clr  RXHOFF,x  XH
 clr  RXLOFF,x  XL
 ldaa  #MONITOR/256
 staa  RPHOFF,x
 ldaa  #MONITOR&255
 staa  RPLOFF,x

 JSR ACINIZ  INITIALIZE CONTROL PORT
 LDX  #MSG1  POINT TO 'SBUG 1.8' MESSAGE
 JSR PDATA  PRINT MSG

 LDAA  #$60   FIXED SIZE FOR CPUXXCMI
 JSR OUT2H OUTPUT HEX BYTE AS ASCII
 LDX  #MSG2  POINT TO MSG 'K' CR/LF + 3 NULS
 JSR PDATA  PRINT MSG

***** NEXTCMD *****

NEXTCMD LDX  #MSG3   POINT TO MSG ">"
 JSR PSTRNG PRINT MSG
 JSR INCH  GET ONE CHAR. FROM TERMINAL
 ANDA #$7F STRIP PARITY FROM CHAR.
 CMPA #$0D IS IT CARRIAGE RETURN ?
 BEQ  NEXTCMD IF CR THEN GET ANOTHER CHAR.
 TAB  PUT CHAR. IN "B" ACCUM.
 CMPA #$20 IS IT CONTROL OR DATA CHAR ?
 BGE  PRTCMD IF CMD CHAR IS DATA, PRNT IT
 LDAA  #'^ ELSE CNTRL CHAR CMD SO...
 JSR OUTCH PRINT "^"
 TBA  RECALL CNTRL CMD CHAR
 ADDA #$40 CONVERT IT TO ASCII LETTER
PRTCMD JSR OUTCH PRNT CMD CHAR
 JSR OUT1S PRNT SPACE
 CMPB #$60
 BLE NXTCH0
 SUBB #$20


***** DO TABLE LOOKUP *****
*   FOR COMMAND FUNCTIONS


NXTCH0 LDX #JMPTAB POINT TO JUMP TABLE
NXTCHR CMPB X DOES COMMAND MATCH TABLE ENTRY ?
 BEQ  JMPCMD BRANCH IF MATCH FOUND
  INX
  INX
  INX  POINT TO NEXT ENTRY IN TABLE
 CMPX #TABEND REACHED END OF TABLE YET ?
 BNE  NXTCHR IF NOT END, CHECK NEXT ENTRY
 LDX  #MSG4  POINT TO MSG "WHAT?"
 JSR PDATA  PRINT MSG
 BRA  NEXTCMD IF NO MATCH, PRMPT FOR NEW CMD
JMPCMD INX
    LDX 0,x
    JSR 0,x
 BRA  NEXTCMD PROMPT FOR NEW COMMAND
*
* "G" GO OR CONTINUE

GO lds  STACK
RTI RTI

* "R" DISPLAY REGISTERS

REGSTR LDX  #MSG5 POINT TO MSG " - "
 JSR PSTRNG PRINT MSG
 JSR PRTSP
 JSR PRTIX
 LDX  #MSG5 POINT TO MSG " - "
 JSR PSTRNG PRINT MSG
 JSR PRTCC
 JSR PRTA
 JSR PRTB
 JMP PRTPC

* ALTER "PC" PROGRAM COUNTER

ALTRPC JSR PRTPC $FCF5 PRINT MSG " PC = "
 JSR OUT1S OUTPUT SPACE
 JSR IN1ADR GET NEW CONTENTS FOR "PC"
 BVS  ALTPCD EXIT IF INVALID HEX
 ldx  STACK
 inx
 ldaa XTEMP
 staa RPHOFF,x
 ldaa XTEMP+1
 staa RPLOFF,x
ALTPCD RTS


* ALTER "X" INDEX REGISTER

ALTRX JSR PRTIX $FCE0 PRINT MSG " IX = "
 JSR OUT1S OUTPUT SPACE
 JSR IN1ADR
 BVS  ALTXD
 ldaa XTEMP
 ldx  STACK
 inx
 staa RXHOFF,x
 ldaa XTEMP+1
 staa RXLOFF,x
ALTXD RTS

* ALTER "B" ACCUMULATOR

ALTRB JSR PRTB $FD09 PRINT MSG " B = "
 JSR OUT1S OUTPUT SPACE
 JSR BYTE INPUT BYTE (2 HEX CHAR)
 BVS  ALTBD
 ldx  STACK
 inx
 STAA  RRBOFF,x
ALTBD RTS       $F91C


* ALTER "A" ACCUMULATOR
*
ALTRA JSR PRTA $FCFF RINT MSG " A = "
 JSR OUT1S OUTPUT SPACE
 JSR BYTE INPUT BYTE (2 HEX CHAR)
 BVS  ALTAD
 ldx  STACK
 inx
 STAA  RRAOFF,x
ALTAD RTS


* ALTER "CC" REGISTER

ALTRCC JSR PRTCC $FD13 PRINT MSG " CC: "
 JSR OUT1S OUTPUT SPACE
 JSR BYTE INPUT BYTE (2 HEX CHAR)
 BVS  ALTCCD
 ORAA  #$80 SETS "E" FLAG IN PRINT LIST
 ldx  STACK
 inx
 STAA RCCOFF,x
ALTCCD RTS

***** "M" MEMORY EXAMINE AND CHANGE *****

MEMCHG JSR IN1ADR  INPUT ADDRESS
 BVS  CHRTN  IF NOT HEX, RETURN
MEMC2 stx  YTEMP
 LDX  #MSG5 POINT TO MSG " - "
 JSR PSTRNG PRINT MSG
 ldx YTEMP
 JSR OUT4H PRINT ADDR IN HEX
 JSR OUT1S OUTPUT SPACE
 ldx YTEMP
 LDAA  0,x GET CONTENTS OF CURRENT ADDR.
 JSR OUT2H OUTPUT CONTENTS IN ASCII
 JSR OUT1S OUTPUT SPACE
 JSR BYTE LOOP WAITING FOR OPERATOR INPUT
 BVC  CHANGE IF VALID HEX GO CHANGE MEM. LOC.
 CMPA #8  IS IT A BACKSPACE (CNTRL H)?
 BEQ  MEMC2 PROMPT OPERATOR AGAIN
 CMPA #$18  IS IT A CANCEL (CNTRL X)?
 BEQ  MEMC2 PROMPT OPERATOR AGAIN
 CMPA #'^  IS IT AN UP ARROW?
 BEQ  BACK  DISPLAY PREVIOUS BYTE
 CMPA #$D  IS IT A CR?
 BNE  FORWRD  DISPLAY NEXT BYTE
CHRTN RTS EXIT ROUTINE


CHANGE STAA ,X  CHANGE BYTE IN MEMORY
 CMPA ,X  DID MEMORY BYTE CHANGE?
 BEQ  FORWRD    $F972
 JSR OUT1S OUTPUT SPACE
 LDAA  #'?  LOAD QUESTION MARK
 JSR OUTCH  PRINT IT
FORWRD INX POINT TO NEXT HIGHER MEM LOCATION
 BRA  MEMC2 PRINT LOCATION & CONTENTS
BACK DEX  POINT TO LAST MEM LOCATION
 BRA  MEMC2 PRINT LOCATION & CONTENTS

* "S" DISPLAY STACK
* HEX-ASCII DISPLAY OF CURRENT STACK CONTENTS FROM
* CURRENT STACK POINTER TO INTERNAL STACK LIMIT.

DISSTK JSR PRTSP PRINT CURRENT STACK POINTER
 tsx
 stx    YTEMP
 LDX  #STACK LOAD INTERNAL STACK AS UPPER LIMIT
 INX  POINT TO CURRENT STACK
 BRA  MDUMP1 ENTER MEMORY DUMP OF STACK CONTENTS

* "E" DUMP MEMORY FOR EXAMINE IN HEX AND ASCII
* AFTER CALLING 'IN2ADR' LOWER ADDRESS IN XTEMP1
*                        UPPER ADDRESS IN XTEMP2
* IF HEX ADDRESSES ARE INVALID (V)=1.

MEMDUMP JSR IN2ADR INPUT ADDRESS BOUNDRIES
 BVS  EDPRTN NEW COMMAND IF ILLEGAL HEX
MDUMP1  LDAA XTEMP+1
        SUBA YTEMP+1
        LDAB XTEMP
        SBCB YTEMP
        BNE  AJDUMP
        BCC  AJDUMP
EDPRTN  RTS

* ADJUST LOWER AND UPPER ADDRESS LIMITS
* TO EVEN 16 BYTE BOUNDRIES.

* IF LOWER ADDR = $4532
* LOWER BOUNDS WILL BE ADJUSTED TO = $4530.

* IF UPPER ADDR = $4567
* UPPER BOUNDS WILL BE ADJUSTED TO = $4570.

* ENTER WITH LOWER ADDRESS IN X-REG.
*           -UPPER ADDRESS ON TOP OF STACK.

AJDUMP stx      DTEMP GET UPPER ADDR IN D-REG
        LDAA     DTEMP
        LDAB    DTEMP+1
        ADDB    #16
        ADCA    #0
        ANDB    #$F0
        staa    DTEMP
        stab    DTEMP+1
        ldaa    YTEMP
        ldab    YTEMP+1
        andb    #$f0
        staa    YTEMP
        stab    YTEMP+1
        ldx     YTEMP
NXTLIN  cmpx    DTEMP
 BEQ  SKPDMP IF EQUAL SKIP HEX-ASCII DUMP
 ldx  YTEMP
 JSR INCHEK CHECK FOR INPUT FROM KEYBOARD
 BEQ  EDUMP IF NONE, CONTINUE WITH DUMP
SKPDMP RTS

* PRINT 16 HEX BYTES FOLLOWED BY 16 ASCII CHARACTERS
* FOR EACH LINE THROUGHOUT ADDRESS LIMITS.

EDUMP stx XTEMP
 LDX  #MSG5 POINT TO MSG " - "
 JSR PSTRNG PRINT MSG
 ldx XTEMP
 JSR OUT4H PRINT THE ADDRESS
 JSR OUT2S PRINT 2 SPACES
 ldx XTEMP
 LDAB  #$10 LOAD COUNT OF 16 BYTES TO DUMP
ELOOP LDAA  ,X GET FROM MEMORY HEX BYTE TO PRINT
 INX
 JSR OUT2H OUTPUT HEX BYTE AS ASCII
 JSR OUT1S OUTPUT SPACE
 DECB      $F9D1 DECREMENT BYTE COUNT
 BNE  ELOOP CONTINUE TIL 16 HEX BYTES PRINTED

* PRINT 16 ASCII CHARACTERS
* IF NOT PRINTABLE OR NOT VALID
* ASCII PRINT A PERIOD (.)
 JSR OUT2S 2 SPACES
 LDX  XTEMP GET LOW LIMIT FRM STACK - ADJ STACK
 LDAB  #$10 SET ASCII CHAR TO PRINT = 16
EDPASC LDAA  ,X GET CHARACTER FROM MEMORY
 INX
 CMPA #$20 IF LESS THAN $20, NON-PRINTABLE?
 BCS  PERIOD IF SO, PRINT PERIOD INSTEAD
 CMPA #$7E IS IT VALID ASCII?
 BLS  PRASC IF SO PRINT IT
PERIOD LDAA  #'. LOAD A PERIOD (.)
PRASC JSR OUTCH PRINT ASCII CHARACTER
 DECB DECREMENT COUNT
 BNE  EDPASC
 stx  YTEMP
 BRA  NXTLIN

***** "B" SET BREAKPOINT *****

BRKPNT JSR IN1ADR GET BREAKPOINT ADDRESS
 BVS  EXITBP EXIT IF INVALID HEX ADDR.
 stx DTEMP
 ldaa   DTEMP
 ldab   DTEMP+1
 suba   #STACK
 bhs    BPERR
 sbcb   #STACK+1
 bhs    BPERR
 stx    XTEMP
 LDX  #$FFFF LOAD DUMMY ADDR TO TEST BP TABLE
 JSR BPTEST TEST BP TABLE FOR FREE SPACE
 tpa
 ldx    XTEMP
 tap
 BEQ  BPERR (Z) SET, OUT OF BP TABLE SPACE
 LDAA  ,X GET DATA AT BREAKPOINT ADDRESS
 CMPA #$3F IS IT A SWI?
 BEQ  BPERR IF SWI ALREADY, INDICATE ERROR
 ldx  YTEMP
 STAA  ,x SAVE DATA BYTE IN BP TABLE
 inx
 LDAA  XTEMP
 STAA  0,x
 LDAA  XTEMP+1
 STAA  1,x
 ldx   XTEMP
 LDAA  #$3F LOAD A SWI ($3F)
 STAA  ,X SAVE SWI AT BREAKPOINT ADDRESS
EXITBP RTS

*  INDICATE ERROR SETTING BREAKPOINT

BPERR JSR OUT1S OUTPUT SPACE
 LDAA  #'? LOAD (?), INDICATE BREAKPOINT ERROR
 JMP OUTCH PRINT "?"

*** "X" CLEAR OUTSTANDING BREAKPOINTS ***

XBKPNT LDX  #BPTBL POINT TO BREAKPOINT TABLE
 stx  YTEMP
 LDAB  #8 LOAD BREAKPOINT COUNTER
XBPLP STAB BTEMP
 BSR RPLSWI REMOVE USED ENTRY IN BP TABLE
 LDAB BTEMP
 DECB  $FAAC DECREMENT BP COUNTER
 BNE XBPLP END OF BREAKPOINT TABLE?
 RTS

***** SWI ENTRY POINT *****

SWIE TSX  TRANSFER STACK TO USER POINTER
     STX UTEMP
 ldx  UTEMP
 LDX  RPHOFF,X LOAD PC FROM STACK INTO X-REG
 DEX  ADJUST ADDR DOWN 1 BYTE.
 BSR BPTEST FIND BREAKPOINT IN BP TABLE
 BEQ  REGPR IF FOUND, REPLACE DATA AT BP ADDR
 STX XTEMP
 LDX UTEMP
 LDAA XTEMP
 LDAB XTEMP+1
 STAA RPHOFF,X
 STAB RPLOFF,X
 BSR RPLSWI GO REPLACE SWI WITH ORIGINAL DATA
REGPR JSR REGSTR GO PRINT REGISTERS
 JMP NEXTCMD GET NEXT COMMAND
RPLSWI LDX YTEMP
 LDAA  1,X LOAD BP ADDRESS FROM BP TABLE
 LDAB  2,x
 suba #STACK
 bhs  FFSTBL
 sbcb #STACK+1
 bhs  FFSTBL
 ldx  XTEMP
 LDAA  ,X GET DATA FROM BP ADDRESS
 CMPA #$3F IS IT SWI?
 BNE  FFSTBL IF NOT, RESET TABLE ENTRY TO $FF'S
 ldx  YTEMP
 LDAA  ,X GET ORIGINAL DATA FROM BP TABLE
 ldx  XTEMP
 STAA  ,X      $FAD3 RESTORE DATA AT BP ADDRESS
FFSTBL LDAA  #$FF LOAD $FF IN A-ACC
 ldx   YTEMP
 STAA  ,X RESET BREAKPOINT TABLE DATA TO $FF'S
 inx
 STAA  ,X RESET BREAKPOINT TABLE ADDR TO $FF'S
 inx
 STAA  ,X
 inx
 RTS

** SEARCH BREAKPOINT TABLE FOR MATCH **

BPTEST stx  XTEMP
 LDX  #BPTBL POINT TO BREAKPOINT TABLE
 stx YTEMP
 LDAB  #8 LOAD BREAKPOINT COUNTER
FNDBP ldx YTEMP
 LDAA  ,X LOAD DATA BYTE
 inx
 ldab XTEMP
 SUBB YTEMP
 BNE  FNDB
 LDAB XTEMP+1
 SBCB YTEMP+1
 BEQ  BPADJ IF SO, ADJUST POINTER FOR TABLE ENTRY
FNDB inx
 inx
 stx  YTEMP
 DECB IF NOT, DECREMENT BREAKPOINT COUNTER
 BNE  FNDBP AND LOOK FOR NEXT POSSIBLE MATCH
 ldx XTEMP
 RTS

BPADJ ldx YTEMP
    dex
    dex
    dex
    stx YTEMP
    ldx XTEMP
 RTS

***** "U" MINIDISK BOOT *****

MINBOOT TST  Comreg
 ldaa  #%01000101   DRIVE 0 + 5" mode
 STAA  Drvreg

* DELAY BEFORE ISSUING RESTORE COMMAND
 LDAB  #3
 LDX  #0
LOOP inx
 CMPX #0
 BNE  LOOP
 DECB
 BNE  LOOP

 LDAA  #$09 *LOAD HEAD, VERIFY, 12msec/step
 STAA  Comreg  ISSUE RESTORE COMMAND
LOOP1 LDAB  Drvsta
 BITB #%01000000
 BEQ  LOOP1  LOOP UNTIL THRU
*
 LDAA  #1
 STAA  Secreg SET SECTOR REGISTER TO ONE
 LDAA  #$8C  LOAD HEAD, DELAY 10msec,
 STAA  Comreg  AND READ SINGLE RECORD
 LDX  #$C100
 BRA  LOOP3

LOOP2 LDAA  Datreg
 STAA  ,X
 INX

LOOP3 LDAB  Drvsta FETCH STATUS
 BMI  LOOP2
 BITB #%01000000
 BEQ  LOOP3
 LDAB  Comreg
 BITB #$2C CRC ERROR OR LOST DATA?
 BEQ  LOOP4
 RTS

LOOP4 tsx
  LDAA #$A1
  LDAB #$00
  staa RPHOFF,X
  stab RPLOFF,X
 RTI

* for compatibillity
LRA    clra
   rts


***** "L" LOAD MIKBUG TAPE *****

LOAD    CLR  ECHO  TURN OFF ECHO FLAG
LOAD1   JSR ECHON INPUT 8 BIT BYTE WITH NO ECHO
LOAD2   ORAA #$20
        CMPA #'s IS IT AN "S", START CHARACTER ?
        BNE  LOAD1 IF NOT, DISCARD AND GET NEXT CHAR.
        JSR ECHON
        CMPA #'9 IS IT A "9" , END OF FILE CHAR ?
        BEQ  LOAD21 IF SO, EXIT LOAD
        CMPA #'1 IS IT A "1" , FILE LOAD CHAR ?
        BNE  LOAD2 IF NOT, LOOK FOR START CHAR.
        JSR BYTE INPUT BYTE COUNT
        staa ATEMP
        BVS  LODERR (V) C-CODE SET, ILLEGAL HEX
        JSR IN1ADR INPUT LOAD ADDRESS
        BVS  LODERR (V) C-CODE SET, ADDR NOT HEX
        LDAB XTEMP
        ADDB XTEMP+1
        ADDB ATEMP
        DEC ATEMP  bytecount
        DEC ATEMP
LOAD10 PSHB PUSH CHECKSUM ON STACK
       JSR BYTE INPUT DATA BYTE (2 HEX CHAR)
       PULB POP CHECKSUM FROM STACK
       BVS  LODERR (V) SET, DATA BYTE NOT HEX
       staa BTEMP
       ADDB BTEMP
       DEC  ATEMP  DECREMENT BYTE COUNT 1
       BEQ  LOAD16 IF BYTE COUNT ZERO, TEST CHECKSUM
       STAA  ,X SAVE DATA BYTE IN MEMORY
       INX
       BRA  LOAD10 GET NEXT DATA BYTE
LODERR CLRB ERROR CONDITION, ZERO CHECKSUM
LOAD16 CMPB #$FF CHECKSUM OK?
       BEQ  LOAD IF SO, LOAD NEXT LINE
       LDAA  #'? LOAD (?) ERROR INDICATOR
LOAD21 COM  ECHO TURN ECHO ON
 JMP OUTCH OUTPUT IT

***** "P" PUNCH MIKBUG TAPE *****

PUNCH CLR  BTEMP  CLEAR RESERVED BYTE
 JSR IN2ADR GET BEGIN AND END ADDRESS
 BVS  PUNEXT (V) C-CODE SET, EXIT PUNCH
 ldaa XTEMP
 ldab XTEMP+1
 suba YTEMP
 bhi  PUNEXT
 sbcb YTEMP+1
 BCS  PUNEXT IF BEGIN GREATER THAN END, EXIT PUNCH
 inx
 STX  XTEMP STORE END ADDR
 LDAA  #$12 LOAD 'DC2' PUNCH ON CODE
 JSR OUTCH OUTPUT IT TO TERMINAL
PUNCH2
    LDAA XTEMP
    LDAB XTEMP+1
    SUBA YTEMP
    BHI  PUNCH3
    SBCB YTEMP+1
 CMPB #$20 LESS THAN 32 BYTES?
 BLS  PUNCH4 PUNCH THAT MANY BYTES
PUNCH3 LDAB  #$20 LOAD BYTE COUNT OF 32.
PUNCH4 STAB  BTEMP  STORE BYTE COUNT
 LDX  #MSG20 POINT TO MSG "S1"
 JSR PSTRNG PRINT MSG
 ADDB #3 ADD 3 BYTES TO BYTE COUNT
 TBA  GET BYTE COUNT IN A-ACC TO PUNCH
 JSR OUT2H OUTPUT BYTE COUNT
 LDX  YTEMP LOAD BEGIN ADDRESS
 JSR OUT4H PUNCH ADDRESS
 ADDB YTEMP  ADD ADDR MSB TO CHECKSUM
 ADDB YTEMP+1 ADD ADDR LSB TO CHECKSUM
PUNCHL ADDB ,X ADD DATA BYTE TO CHECKSUM
 LDAA  ,X LOAD DATA BYTE TO PUNCH
 inx
 JSR OUT2H OUTPUT DATA BYTE
 DEC  BTEMP DECREMENT BYTE COUNT
 BNE  PUNCHL NOT DONE, PUNCH NEXT BYTE
 COMB 1's COMPLIMENT CHECKSUM BYTE
 TBA  GET IT IN A-ACC TO PUNCH
 JSR OUT2H OUTPUT CHECKSUM BYTE
 STX  YTEMP SAVE X-REG AS NEW PUNCH ADDR
 CMPX XTEMP  COMPARE IT TO END ADDR
 BNE  PUNCH2      $FCB5 PUNCH NOT DONE, CONT.
PUNEXT LDAA  #$14 LOAD 'DC4' PUNCH OFF CODE
 JSR OUTCH OUTPUT IT
 RTS


PRTSP LDX  #MSG10 POINT TO MSG "SP="
 JSR PDATA  PRINT MSG
 ldx STACK
 inx
 JMP OUT4H
PRTIX LDX  #MSG14 POINT TO MSG "IX="
 JSR PDATA  PRINT MSG
 ldx STACK
 ldx  RXHOFF+1,x
 JMP OUT4H
PRTPC LDX  #MSG11 POINT TO MSG "PC="
 JSR PDATA  PRINT MSG
 ldx STACK
 ldx  RPHOFF+1,x
 JMP  OUT4H
PRTA LDX  #MSG16 POINT TO MSG "A="
 JSR PDATA  PRINT MSG
 ldx STACK
 LDAA RRAOFF+1,x
 JMP OUT2H OUTPUT HEX BYTE AS ASCII
PRTB LDX  #MSG17 POINT TO MSG "B="
 JSR PDATA  PRINT MSG
 ldx STACK
 LDAA  RRBOFF+1,x
 BRA OUT2H OUTPUT HEX BYTE AS ASCII
PRTCC LDX  #MSG18 POINT TO MSG "CC:"
 JSR PDATA  PRINT MSG
 ldx STACK
 LDAA RCCOFF+1,x
 LDX  #MSG19 POINT TO MSG "11HINZVC"
 BRA BIASCI OUTPUT IN BINARY/ASCII FORMAT

* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE
* OPERATOR TO INPUT TWO VALID HEX ADDRESSES.
* THE FIRST ADDRESS INPUT IS RETURNED IN "IY".
* THE SECOND IS RETURNED IN "IX". THE "V" BIT
* IN THE C-CODE REG. IS SET IF AN INVALID HEX
* ADDRESS IS INPUT.

IN2ADR BSR IN1ADR GET FIRST ADDRESS
 BVS NOTHEX EXIT IF NOT VALID HEX
 STX  YTEMP
 LDAA #'-
 JSR OUTCH PRINT " - "

* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE
* OPERATOR TO INPUT ONE VALID HEX ADDRESS. THE
* ADDRESS IS RETURNED IN THE "X" REGISTER.

IN1ADR BSR BYTE INPUT BYTE (2 HEX CHAR)
 BVS NOTHEX EXIT IF NOT VALID HEX
 STAA XTEMP
 BSR BYTE INPUT BYTE (2 HEX CHAR)
 BVS NOTHEX
 STAA XTEMP+1
 LDX XTEMP
 RTS

***** INPUT BYTE (2 HEX CHAR.) *****

BYTE BSR INHEX GET HEX LEFT
 BVS NOTHEX EXIT IF NOT VALID HEX
 ASLA
 ASLA
 ASLA SHIFT INTO LEFT NIBBLE
 ASLA
 TAB  PUT HEXL IN "B"
 BSR INHEX GET HEX RIGHT
 BVS NOTHEX EXIT IF NOT VALID HEX
 STAB BTEMP
 ADDA BTEMP ADD HEXL TO HEXR AND ADJ. STK
 RTS RETURN WITH HEX L&R IN "A"


INHEX BSR ECHON INPUT ASCII CHAR.
 CMPA #'0 IS IT > OR = "0" ?
 BCS NOTHEX IF LESS IT AIN'T HEX
 CMPA #'9 IS IT < OR = "9" ?
 BHI INHEXA IF > MAYBE IT'S ALPHA
 SUBA #$30 ASCII ADJ. NUMERIC
 RTS


INHEXA CMPA #'A IS IT > OR = "A"
 BCS NOTHEX IF LESS IT AIN'T HEX
 CMPA #'F IS IT < OR = "F" ?
 BHI INHEXL IF > IT AIN'T HEX
 SUBA #$37 ASCII ADJ. ALPHA
 RTS

INHEXL CMPA #'a IS IT > OR = "a"
 BCS NOTHEX IF LESS IT AIN'T HEX
 CMPA #'f IS IT < "f"
 BHI NOTHEX IF > IT AIN'T HEX
 SUBA #$57 ADJUST TO LOWER CASE
 RTS


NOTHEX psha
    TPA
    ORAA #2  #2 SET (V) FLAG IN C-CODES REGISTER
    TAP
    pula
 RTS


OUT4H stx XWORK2  PUSH X-REG. ON THE STACK
 LDAA XWORK2  MS BYTE OF X-REG INTO A-ACC.
 BSR OUTHL OUTPUT HEX LEFT
 LDAA XWORK2+1 LS BYTE OF X-REG INTO A-ACC.
OUTHL EQU *
OUT2H PSHA SAVE IT BACK ON STACK
 LSRA CONVERT UPPER HEX NIBBLE TO ASCII
 LSRA
 LSRA
 LSRA
 BSR XASCII PRINT HEX NIBBLE AS ASCII
OUTHR PULA CONVERT LOWER HEX NIBBLE TO ASCII
 ANDA #$0F STRIP LEFT NIBBLE
XASCII ADDA #$30 ASCII ADJ
 CMPA #$39 IS IT < OR = "9" ?
 BLE  OUTC IF LESS, OUTPUT IT
 ADDA #7 IF > MAKE ASCII LETTER
OUTC BRA  OUTCH OUTPUT CHAR

* BINARY / ASCII --- THIS ROUTINE
* OUTPUTS A BYTE IN ENHANCED
* BINARY FORMAT. THE ENHANCEMENT
* IS DONE BY SUBSTITUTING ASCII
* LETTERS FOR THE ONES IN THE BYTE.
* THE ASCII ENHANCEMENT LETTERS
* ARE OBTAINED FROM THE STRING
* POINTED TO BY THE INDEX REG. "X".

BIASCI staa ATEMP  SAVE "A"
 LDAB  #8 PRESET LOOP# TO BITS PER BYTE
OUTBA LDAA ,X GET LETTER FROM STRING
 INX
 ASL  ATEMP  TEST BYTE FOR "1" IN B7
 BCS PRTBA IF ONE PRINT LETTER
 LDAA #'- IF ZERO PRINT "-"
PRTBA BSR OUTCH PRINT IT
 BSR OUT1S PRINT SPACE
 DECB           SUB 1 FROM #BITS YET TO PRINT
 BNE OUTBA
 RTS

* PRINT STRING PRECEEDED BY A CR & LF.

PSTRNG BSR PCRLF PRINT CR/LF
 BRA  PDATA  PRINT STRING POINTED TO BY IX

* PCRLF

PCRLF STX XWORK2 SAVE IX
 LDX  #MSG2+1  POINT TO MSG CR/LF + 3 NULS
 BSR PDATA  PRINT MSG
 LDX XWORK2 RESTORE IX
 RTS
PRINT BSR OUTCH

* PDATA

PDATA LDAA  ,X GET 1st CHAR. TO PRINT
 inx
 CMPA #4 IS IT EOT?
 BNE  PRINT IF NOT EOT PRINT IT
 RTS


ECHON TST  ECHO IS ECHO REQUIRED ?
 BEQ  INCH ECHO NOT REQ. IF CLEAR

* INCHE

* ---GETS CHARACTER FROM TERMINAL AND
* ECHOS SAME. THE CHARACTER IS RETURNED
* IN THE "A" ACCUMULATOR WITH THE PARITY
* BIT MASKED OFF. ALL OTHER REGISTERS
* ARE PRESERVED.

INCHE BSR INCH GET CHAR FROM TERMINAL
 ANDA #$7F      STRIP PARITY FROM CHAR.
 BRA  OUTCH     ECHO CHAR TO TERMINAL

* INCH

* GET CHARACTER FROM TERMINAL. RETURN
* CHARACTER IN "A" ACCUMULATOR AND PRESERVE
* ALL OTHER REGISTERS. THE INPUT CHARACTER
* IS 8 BITS AND IS NOT ECHOED.


INCH STX XWORK1 SAVE IX
 LDX  CPORT POINT TO TERMINAL PORT
GETSTA LDAA  ,X  FETCH PORT STATUS
 BITA #1 TEST READY BIT, RDRF ?
 BEQ  GETSTA IF NOT RDY, THEN TRY AGAIN
 LDAA  1,X FETCH CHAR
 LDX XWORK1
 RTS

* INCHEK

* CHECK FOR A CHARACTER AVAILABLE FROM
* THE TERMINAL. THE SERIAL PORT IS CHECKED
* FOR READ READY. ALL REGISTERS ARE
* PRESERVED, AND THE "Z" BIT WILL BE
* CLEAR IF A CHARACTER CAN BE READ.


INCHEK PSHA SAVE A ACCUM.
 STX  XWORK1
 LDX  CPORT
 LDAA  0,x FETCH PORT STATUS
 LDX XWORK1
 BITA #1 TEST READY BIT, RDRF ?
 PULA RESTORE A ACCUM.
 RTS

OUT2S BSR OUT1S OUTPUT 2 SPACES
OUT1S LDAA  #$20  OUTPUT 1 SPACE


* OUTCH

* OUTPUT CHARACTER TO TERMINAL.
* THE CHAR. TO BE OUTPUT IS
* PASSED IN THE A REGISTER.
* ALL REGISTERS ARE PRESERVED.

OUTCH PSHA
 STX XWORK1 SAVE IX
 LDX  CPORT GET ADDR. OF TERMINAL
FETSTA LDAA  ,X FETCH PORT STATUS
 BITA #2 TEST TDRE, OK TO XMIT ?
 BEQ  FETSTA IF NOT LOOP UNTIL RDY
 PULS A GET CHAR. FOR XMIT
 STAA  1,X XMIT CHAR.
 LDX XWORK1 RESTORE IX
 RTS


ACINIZ LDX  CPORT  POINT TO CONTROL PORT ADDRESS
 LDAA  #3  RESET ACIA PORT CODE
 STAA  ,X  STORE IN CONTROL REGISTER
 LDAA  #$11  SET 8 DATA, 2 STOP AN 0 PARITY
 STAA  ,X  STORE IN CONTROL REGISTER
 TST  1,X  ANYTHING IN DATA REGISTER?
 LDAA  #$FF  TURN ON ECHO FLAG
 STAA  ECHO
 RTS


* MONITOR KEYBOARD COMMAND JUMP TABLE


JMPTAB EQU *
 FCB 1 " ^A "  $F91D
 FDB ALTRA
 FCB 2 " ^B "  $F90F
 FDB ALTRB
 FCB 3 " ^C "  $F92B
 FDB ALTRCC
 FCB $10 " ^P "  $F8C9
 FDB ALTRPC
 FCB $18 " ^X "  $F8F3
 FDB ALTRX

 FCC 'B'
 FDB BRKPNT *$FA78
 FCC 'E'
 FDB MEMDUMP *$F990
 FCC 'G'
 FDB GO *$F89F
 FCC 'L'
 FDB LOAD *$FC09
 FCC 'M'
 FDB MEMCHG *$F93B
 FCC 'P'
 FDB PUNCH *$FC64
 FCC 'R'
 FDB REGSTR *$F8A2
 FCC 'S'
 FDB DISSTK *$F984
 FCC 'U'
 FDB MINBOOT *$FBB0
 FCC 'X'
 FDB XBKPNT *$FAA4

TABEND EQU *

* ** 63X09 VECTOR ADDRESSES **

* FOLLOWING ARE THE ADDRESSES OF THE VECTOR ROUTINES
* FOR THE 63X09 PROCESSOR. DURING INITIALIZATION THEY
* ARE RELOCATED TO RAM FROM $DFC0 TO $DFCF. THEY ARE
* RELOCATED TO RAM SO THAT THE USER MAY REVECTOR TO
* HIS OWN ROUTINES IF HE SO DESIRES.


RAMVEC
 FDB START  NMI
 FDB SWIE   SWI-V
 FDB RTI    IRQ-V


* PRINTABLE MESSAGE STRINGS
MSG1 FCB $D,$A,  CR/LF,
 FCC 'SB68 1.8 - '
 FCB 4
MSG2 FCB 'K,$D,$A,4
MSG3 FCC '>'
 FCB 4
MSG4 FCC 'WHAT?'
 FCB 4
MSG5 FCC ' - '
 FCB 4
MSG6 FCC ', PASS '
 FCB 4
MSG7 FCC ', BITS IN ERROR: '
 FCB 4
MSG8 FCC ' => '
 FCB 4
MSG9 FCC '76543210'
MSG10 FCC '  SP='
 FCB 4
MSG11 FCC '  PC='
 FCB 4
MSG14 FCC '  IX='
 FCB 4
MSG16 FCC '  A='
 FCB 4
MSG17 FCC '  B='
 FCB 4
MSG18 FCC '  CC: '
 FCB 4
MSG19 FCC '11HINZVC'
MSG20 FCC 'S1'
 FCB 4


* POWER UP/ RESET/ NMI ENTRY POINT
START   equ   *
        lds     #romstk     set STACK
        sts     STACK

*
*  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
* 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K 4K I/O,ROM
*
        JMP MONITOR INITIALIZATION IS COMPLETE

V1 LDAA TRAP
   LDAB TRAP+1
   bra  V10
V4 LDAA IRQ
   LDAB IRQ+1
   bra  V10
V5 LDAA SWI
   LDAB SWI+1
V10 PSHB
    PSHA
    RTS

* 6809 VECTORS
 ORG $FFF8

 FDB V4    IRQ-V
 FDB V5    SWI-V
 FDB V1    NMI-V
 FDB START RESTART-V
 END
